// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gridmr.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_gridmr_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_gridmr_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_gridmr_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_gridmr_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_gridmr_2eproto;
namespace gridmr {
class FileChunk;
struct FileChunkDefaultTypeInternal;
extern FileChunkDefaultTypeInternal _FileChunk_default_instance_;
class JobRequest;
struct JobRequestDefaultTypeInternal;
extern JobRequestDefaultTypeInternal _JobRequest_default_instance_;
class JobResponse;
struct JobResponseDefaultTypeInternal;
extern JobResponseDefaultTypeInternal _JobResponse_default_instance_;
class ReceiveFileRequest;
struct ReceiveFileRequestDefaultTypeInternal;
extern ReceiveFileRequestDefaultTypeInternal _ReceiveFileRequest_default_instance_;
class SendFileResponse;
struct SendFileResponseDefaultTypeInternal;
extern SendFileResponseDefaultTypeInternal _SendFileResponse_default_instance_;
class TaskRequest;
struct TaskRequestDefaultTypeInternal;
extern TaskRequestDefaultTypeInternal _TaskRequest_default_instance_;
class TaskResponse;
struct TaskResponseDefaultTypeInternal;
extern TaskResponseDefaultTypeInternal _TaskResponse_default_instance_;
class TaskResult;
struct TaskResultDefaultTypeInternal;
extern TaskResultDefaultTypeInternal _TaskResult_default_instance_;
class TaskResultResponse;
struct TaskResultResponseDefaultTypeInternal;
extern TaskResultResponseDefaultTypeInternal _TaskResultResponse_default_instance_;
class TaskResult_WordCountResultsEntry_DoNotUse;
struct TaskResult_WordCountResultsEntry_DoNotUseDefaultTypeInternal;
extern TaskResult_WordCountResultsEntry_DoNotUseDefaultTypeInternal _TaskResult_WordCountResultsEntry_DoNotUse_default_instance_;
class WorkerRegistrationRequest;
struct WorkerRegistrationRequestDefaultTypeInternal;
extern WorkerRegistrationRequestDefaultTypeInternal _WorkerRegistrationRequest_default_instance_;
class WorkerRegistrationResponse;
struct WorkerRegistrationResponseDefaultTypeInternal;
extern WorkerRegistrationResponseDefaultTypeInternal _WorkerRegistrationResponse_default_instance_;
}  // namespace gridmr
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace gridmr {
enum TaskResponse_TaskType : int {
  TaskResponse_TaskType_NO_TASK = 0,
  TaskResponse_TaskType_MAP_TASK = 1,
  TaskResponse_TaskType_REDUCE_TASK = 2,
  TaskResponse_TaskType_TaskResponse_TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskResponse_TaskType_TaskResponse_TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskResponse_TaskType_IsValid(int value);
extern const uint32_t TaskResponse_TaskType_internal_data_[];
constexpr TaskResponse_TaskType TaskResponse_TaskType_TaskType_MIN = static_cast<TaskResponse_TaskType>(0);
constexpr TaskResponse_TaskType TaskResponse_TaskType_TaskType_MAX = static_cast<TaskResponse_TaskType>(2);
constexpr int TaskResponse_TaskType_TaskType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
TaskResponse_TaskType_descriptor();
template <typename T>
const std::string& TaskResponse_TaskType_Name(T value) {
  static_assert(std::is_same<T, TaskResponse_TaskType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskType_Name().");
  return TaskResponse_TaskType_Name(static_cast<TaskResponse_TaskType>(value));
}
template <>
inline const std::string& TaskResponse_TaskType_Name(TaskResponse_TaskType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskResponse_TaskType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool TaskResponse_TaskType_Parse(absl::string_view name, TaskResponse_TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskResponse_TaskType>(
      TaskResponse_TaskType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorkerRegistrationResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.WorkerRegistrationResponse) */ {
 public:
  inline WorkerRegistrationResponse() : WorkerRegistrationResponse(nullptr) {}
  ~WorkerRegistrationResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerRegistrationResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline WorkerRegistrationResponse(const WorkerRegistrationResponse& from) : WorkerRegistrationResponse(nullptr, from) {}
  inline WorkerRegistrationResponse(WorkerRegistrationResponse&& from) noexcept
      : WorkerRegistrationResponse(nullptr, std::move(from)) {}
  inline WorkerRegistrationResponse& operator=(const WorkerRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerRegistrationResponse& operator=(WorkerRegistrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerRegistrationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerRegistrationResponse*>(
        &_WorkerRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(WorkerRegistrationResponse& a, WorkerRegistrationResponse& b) { a.Swap(&b); }
  inline void Swap(WorkerRegistrationResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerRegistrationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerRegistrationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WorkerRegistrationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerRegistrationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkerRegistrationResponse& from) { WorkerRegistrationResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkerRegistrationResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.WorkerRegistrationResponse"; }

 protected:
  explicit WorkerRegistrationResponse(::google::protobuf::Arena* arena);
  WorkerRegistrationResponse(::google::protobuf::Arena* arena, const WorkerRegistrationResponse& from);
  WorkerRegistrationResponse(::google::protobuf::Arena* arena, WorkerRegistrationResponse&& from) noexcept
      : WorkerRegistrationResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.WorkerRegistrationResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class WorkerRegistrationRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.WorkerRegistrationRequest) */ {
 public:
  inline WorkerRegistrationRequest() : WorkerRegistrationRequest(nullptr) {}
  ~WorkerRegistrationRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkerRegistrationRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline WorkerRegistrationRequest(const WorkerRegistrationRequest& from) : WorkerRegistrationRequest(nullptr, from) {}
  inline WorkerRegistrationRequest(WorkerRegistrationRequest&& from) noexcept
      : WorkerRegistrationRequest(nullptr, std::move(from)) {}
  inline WorkerRegistrationRequest& operator=(const WorkerRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerRegistrationRequest& operator=(WorkerRegistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerRegistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const WorkerRegistrationRequest*>(
        &_WorkerRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(WorkerRegistrationRequest& a, WorkerRegistrationRequest& b) { a.Swap(&b); }
  inline void Swap(WorkerRegistrationRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerRegistrationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerRegistrationRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WorkerRegistrationRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkerRegistrationRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkerRegistrationRequest& from) { WorkerRegistrationRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorkerRegistrationRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.WorkerRegistrationRequest"; }

 protected:
  explicit WorkerRegistrationRequest(::google::protobuf::Arena* arena);
  WorkerRegistrationRequest(::google::protobuf::Arena* arena, const WorkerRegistrationRequest& from);
  WorkerRegistrationRequest(::google::protobuf::Arena* arena, WorkerRegistrationRequest&& from) noexcept
      : WorkerRegistrationRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWorkerIdFieldNumber = 1,
    kAddressFieldNumber = 2,
    kCapacityFieldNumber = 3,
  };
  // string workerId = 1;
  void clear_workerid() ;
  const std::string& workerid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workerid(Arg_&& arg, Args_... args);
  std::string* mutable_workerid();
  PROTOBUF_NODISCARD std::string* release_workerid();
  void set_allocated_workerid(std::string* value);

  private:
  const std::string& _internal_workerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workerid(
      const std::string& value);
  std::string* _internal_mutable_workerid();

  public:
  // string address = 2;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string capacity = 3;
  void clear_capacity() ;
  const std::string& capacity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_capacity(Arg_&& arg, Args_... args);
  std::string* mutable_capacity();
  PROTOBUF_NODISCARD std::string* release_capacity();
  void set_allocated_capacity(std::string* value);

  private:
  const std::string& _internal_capacity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capacity(
      const std::string& value);
  std::string* _internal_mutable_capacity();

  public:
  // @@protoc_insertion_point(class_scope:gridmr.WorkerRegistrationRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr workerid_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr capacity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class TaskResultResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.TaskResultResponse) */ {
 public:
  inline TaskResultResponse() : TaskResultResponse(nullptr) {}
  ~TaskResultResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskResultResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskResultResponse(const TaskResultResponse& from) : TaskResultResponse(nullptr, from) {}
  inline TaskResultResponse(TaskResultResponse&& from) noexcept
      : TaskResultResponse(nullptr, std::move(from)) {}
  inline TaskResultResponse& operator=(const TaskResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResultResponse& operator=(TaskResultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResultResponse* internal_default_instance() {
    return reinterpret_cast<const TaskResultResponse*>(
        &_TaskResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(TaskResultResponse& a, TaskResultResponse& b) { a.Swap(&b); }
  inline void Swap(TaskResultResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResultResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResultResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskResultResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskResultResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskResultResponse& from) { TaskResultResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskResultResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.TaskResultResponse"; }

 protected:
  explicit TaskResultResponse(::google::protobuf::Arena* arena);
  TaskResultResponse(::google::protobuf::Arena* arena, const TaskResultResponse& from);
  TaskResultResponse(::google::protobuf::Arena* arena, TaskResultResponse&& from) noexcept
      : TaskResultResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.TaskResultResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class TaskResult_WordCountResultsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          TaskResult_WordCountResultsEntry_DoNotUse, std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      TaskResult_WordCountResultsEntry_DoNotUse, std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  TaskResult_WordCountResultsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskResult_WordCountResultsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit TaskResult_WordCountResultsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const TaskResult_WordCountResultsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const TaskResult_WordCountResultsEntry_DoNotUse*>(
        &_TaskResult_WordCountResultsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "gridmr.TaskResult.WordCountResultsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class TaskResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.TaskResponse) */ {
 public:
  inline TaskResponse() : TaskResponse(nullptr) {}
  ~TaskResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskResponse(const TaskResponse& from) : TaskResponse(nullptr, from) {}
  inline TaskResponse(TaskResponse&& from) noexcept
      : TaskResponse(nullptr, std::move(from)) {}
  inline TaskResponse& operator=(const TaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResponse& operator=(TaskResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResponse* internal_default_instance() {
    return reinterpret_cast<const TaskResponse*>(
        &_TaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(TaskResponse& a, TaskResponse& b) { a.Swap(&b); }
  inline void Swap(TaskResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskResponse& from) { TaskResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.TaskResponse"; }

 protected:
  explicit TaskResponse(::google::protobuf::Arena* arena);
  TaskResponse(::google::protobuf::Arena* arena, const TaskResponse& from);
  TaskResponse(::google::protobuf::Arena* arena, TaskResponse&& from) noexcept
      : TaskResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using TaskType = TaskResponse_TaskType;
  static constexpr TaskType NO_TASK = TaskResponse_TaskType_NO_TASK;
  static constexpr TaskType MAP_TASK = TaskResponse_TaskType_MAP_TASK;
  static constexpr TaskType REDUCE_TASK = TaskResponse_TaskType_REDUCE_TASK;
  static inline bool TaskType_IsValid(int value) {
    return TaskResponse_TaskType_IsValid(value);
  }
  static constexpr TaskType TaskType_MIN = TaskResponse_TaskType_TaskType_MIN;
  static constexpr TaskType TaskType_MAX = TaskResponse_TaskType_TaskType_MAX;
  static constexpr int TaskType_ARRAYSIZE = TaskResponse_TaskType_TaskType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* TaskType_descriptor() {
    return TaskResponse_TaskType_descriptor();
  }
  template <typename T>
  static inline const std::string& TaskType_Name(T value) {
    return TaskResponse_TaskType_Name(value);
  }
  static inline bool TaskType_Parse(absl::string_view name, TaskType* value) {
    return TaskResponse_TaskType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIntermediateFilesFieldNumber = 4,
    kTaskIdFieldNumber = 2,
    kDataSplitPathFieldNumber = 3,
    kJobIdFieldNumber = 5,
    kTaskTypeFieldNumber = 1,
  };
  // repeated string intermediateFiles = 4;
  int intermediatefiles_size() const;
  private:
  int _internal_intermediatefiles_size() const;

  public:
  void clear_intermediatefiles() ;
  const std::string& intermediatefiles(int index) const;
  std::string* mutable_intermediatefiles(int index);
  void set_intermediatefiles(int index, const std::string& value);
  void set_intermediatefiles(int index, std::string&& value);
  void set_intermediatefiles(int index, const char* value);
  void set_intermediatefiles(int index, const char* value, std::size_t size);
  void set_intermediatefiles(int index, absl::string_view value);
  std::string* add_intermediatefiles();
  void add_intermediatefiles(const std::string& value);
  void add_intermediatefiles(std::string&& value);
  void add_intermediatefiles(const char* value);
  void add_intermediatefiles(const char* value, std::size_t size);
  void add_intermediatefiles(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& intermediatefiles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_intermediatefiles();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_intermediatefiles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_intermediatefiles();

  public:
  // string taskId = 2;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* value);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // string dataSplitPath = 3;
  void clear_datasplitpath() ;
  const std::string& datasplitpath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_datasplitpath(Arg_&& arg, Args_... args);
  std::string* mutable_datasplitpath();
  PROTOBUF_NODISCARD std::string* release_datasplitpath();
  void set_allocated_datasplitpath(std::string* value);

  private:
  const std::string& _internal_datasplitpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datasplitpath(
      const std::string& value);
  std::string* _internal_mutable_datasplitpath();

  public:
  // string jobId = 5;
  void clear_jobid() ;
  const std::string& jobid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jobid(Arg_&& arg, Args_... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* value);

  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(
      const std::string& value);
  std::string* _internal_mutable_jobid();

  public:
  // .gridmr.TaskResponse.TaskType taskType = 1;
  void clear_tasktype() ;
  ::gridmr::TaskResponse_TaskType tasktype() const;
  void set_tasktype(::gridmr::TaskResponse_TaskType value);

  private:
  ::gridmr::TaskResponse_TaskType _internal_tasktype() const;
  void _internal_set_tasktype(::gridmr::TaskResponse_TaskType value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.TaskResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> intermediatefiles_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    ::google::protobuf::internal::ArenaStringPtr datasplitpath_;
    ::google::protobuf::internal::ArenaStringPtr jobid_;
    int tasktype_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class TaskRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.TaskRequest) */ {
 public:
  inline TaskRequest() : TaskRequest(nullptr) {}
  ~TaskRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskRequest(const TaskRequest& from) : TaskRequest(nullptr, from) {}
  inline TaskRequest(TaskRequest&& from) noexcept
      : TaskRequest(nullptr, std::move(from)) {}
  inline TaskRequest& operator=(const TaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskRequest& operator=(TaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskRequest* internal_default_instance() {
    return reinterpret_cast<const TaskRequest*>(
        &_TaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TaskRequest& a, TaskRequest& b) { a.Swap(&b); }
  inline void Swap(TaskRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskRequest& from) { TaskRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.TaskRequest"; }

 protected:
  explicit TaskRequest(::google::protobuf::Arena* arena);
  TaskRequest(::google::protobuf::Arena* arena, const TaskRequest& from);
  TaskRequest(::google::protobuf::Arena* arena, TaskRequest&& from) noexcept
      : TaskRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWorkerIdFieldNumber = 1,
  };
  // string workerId = 1;
  void clear_workerid() ;
  const std::string& workerid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workerid(Arg_&& arg, Args_... args);
  std::string* mutable_workerid();
  PROTOBUF_NODISCARD std::string* release_workerid();
  void set_allocated_workerid(std::string* value);

  private:
  const std::string& _internal_workerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workerid(
      const std::string& value);
  std::string* _internal_mutable_workerid();

  public:
  // @@protoc_insertion_point(class_scope:gridmr.TaskRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr workerid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class SendFileResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.SendFileResponse) */ {
 public:
  inline SendFileResponse() : SendFileResponse(nullptr) {}
  ~SendFileResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SendFileResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SendFileResponse(const SendFileResponse& from) : SendFileResponse(nullptr, from) {}
  inline SendFileResponse(SendFileResponse&& from) noexcept
      : SendFileResponse(nullptr, std::move(from)) {}
  inline SendFileResponse& operator=(const SendFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendFileResponse& operator=(SendFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendFileResponse* internal_default_instance() {
    return reinterpret_cast<const SendFileResponse*>(
        &_SendFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SendFileResponse& a, SendFileResponse& b) { a.Swap(&b); }
  inline void Swap(SendFileResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendFileResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendFileResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SendFileResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SendFileResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SendFileResponse& from) { SendFileResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SendFileResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.SendFileResponse"; }

 protected:
  explicit SendFileResponse(::google::protobuf::Arena* arena);
  SendFileResponse(::google::protobuf::Arena* arena, const SendFileResponse& from);
  SendFileResponse(::google::protobuf::Arena* arena, SendFileResponse&& from) noexcept
      : SendFileResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.SendFileResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class ReceiveFileRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.ReceiveFileRequest) */ {
 public:
  inline ReceiveFileRequest() : ReceiveFileRequest(nullptr) {}
  ~ReceiveFileRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReceiveFileRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReceiveFileRequest(const ReceiveFileRequest& from) : ReceiveFileRequest(nullptr, from) {}
  inline ReceiveFileRequest(ReceiveFileRequest&& from) noexcept
      : ReceiveFileRequest(nullptr, std::move(from)) {}
  inline ReceiveFileRequest& operator=(const ReceiveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceiveFileRequest& operator=(ReceiveFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReceiveFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceiveFileRequest* internal_default_instance() {
    return reinterpret_cast<const ReceiveFileRequest*>(
        &_ReceiveFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ReceiveFileRequest& a, ReceiveFileRequest& b) { a.Swap(&b); }
  inline void Swap(ReceiveFileRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceiveFileRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceiveFileRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReceiveFileRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReceiveFileRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReceiveFileRequest& from) { ReceiveFileRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReceiveFileRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.ReceiveFileRequest"; }

 protected:
  explicit ReceiveFileRequest(::google::protobuf::Arena* arena);
  ReceiveFileRequest(::google::protobuf::Arena* arena, const ReceiveFileRequest& from);
  ReceiveFileRequest(::google::protobuf::Arena* arena, ReceiveFileRequest&& from) noexcept
      : ReceiveFileRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFilePathFieldNumber = 1,
  };
  // string filePath = 1;
  void clear_filepath() ;
  const std::string& filepath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filepath(Arg_&& arg, Args_... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* value);

  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(
      const std::string& value);
  std::string* _internal_mutable_filepath();

  public:
  // @@protoc_insertion_point(class_scope:gridmr.ReceiveFileRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr filepath_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class JobResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.JobResponse) */ {
 public:
  inline JobResponse() : JobResponse(nullptr) {}
  ~JobResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JobResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline JobResponse(const JobResponse& from) : JobResponse(nullptr, from) {}
  inline JobResponse(JobResponse&& from) noexcept
      : JobResponse(nullptr, std::move(from)) {}
  inline JobResponse& operator=(const JobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobResponse& operator=(JobResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobResponse* internal_default_instance() {
    return reinterpret_cast<const JobResponse*>(
        &_JobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(JobResponse& a, JobResponse& b) { a.Swap(&b); }
  inline void Swap(JobResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<JobResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JobResponse& from) { JobResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JobResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.JobResponse"; }

 protected:
  explicit JobResponse(::google::protobuf::Arena* arena);
  JobResponse(::google::protobuf::Arena* arena, const JobResponse& from);
  JobResponse(::google::protobuf::Arena* arena, JobResponse&& from) noexcept
      : JobResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.JobResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class JobRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.JobRequest) */ {
 public:
  inline JobRequest() : JobRequest(nullptr) {}
  ~JobRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JobRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline JobRequest(const JobRequest& from) : JobRequest(nullptr, from) {}
  inline JobRequest(JobRequest&& from) noexcept
      : JobRequest(nullptr, std::move(from)) {}
  inline JobRequest& operator=(const JobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JobRequest& operator=(JobRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JobRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JobRequest* internal_default_instance() {
    return reinterpret_cast<const JobRequest*>(
        &_JobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(JobRequest& a, JobRequest& b) { a.Swap(&b); }
  inline void Swap(JobRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JobRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JobRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<JobRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JobRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JobRequest& from) { JobRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JobRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.JobRequest"; }

 protected:
  explicit JobRequest(::google::protobuf::Arena* arena);
  JobRequest(::google::protobuf::Arena* arena, const JobRequest& from);
  JobRequest(::google::protobuf::Arena* arena, JobRequest&& from) noexcept
      : JobRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJobIdFieldNumber = 1,
    kMapFunctionFieldNumber = 2,
    kReduceFunctionFieldNumber = 3,
    kInputDataPathFieldNumber = 4,
    kNumReducersFieldNumber = 5,
  };
  // string jobId = 1;
  void clear_jobid() ;
  const std::string& jobid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jobid(Arg_&& arg, Args_... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* value);

  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(
      const std::string& value);
  std::string* _internal_mutable_jobid();

  public:
  // string mapFunction = 2;
  void clear_mapfunction() ;
  const std::string& mapfunction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mapfunction(Arg_&& arg, Args_... args);
  std::string* mutable_mapfunction();
  PROTOBUF_NODISCARD std::string* release_mapfunction();
  void set_allocated_mapfunction(std::string* value);

  private:
  const std::string& _internal_mapfunction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapfunction(
      const std::string& value);
  std::string* _internal_mutable_mapfunction();

  public:
  // string reduceFunction = 3;
  void clear_reducefunction() ;
  const std::string& reducefunction() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reducefunction(Arg_&& arg, Args_... args);
  std::string* mutable_reducefunction();
  PROTOBUF_NODISCARD std::string* release_reducefunction();
  void set_allocated_reducefunction(std::string* value);

  private:
  const std::string& _internal_reducefunction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reducefunction(
      const std::string& value);
  std::string* _internal_mutable_reducefunction();

  public:
  // bytes inputDataPath = 4;
  void clear_inputdatapath() ;
  const std::string& inputdatapath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_inputdatapath(Arg_&& arg, Args_... args);
  std::string* mutable_inputdatapath();
  PROTOBUF_NODISCARD std::string* release_inputdatapath();
  void set_allocated_inputdatapath(std::string* value);

  private:
  const std::string& _internal_inputdatapath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inputdatapath(
      const std::string& value);
  std::string* _internal_mutable_inputdatapath();

  public:
  // int32 numReducers = 5;
  void clear_numreducers() ;
  ::int32_t numreducers() const;
  void set_numreducers(::int32_t value);

  private:
  ::int32_t _internal_numreducers() const;
  void _internal_set_numreducers(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.JobRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr jobid_;
    ::google::protobuf::internal::ArenaStringPtr mapfunction_;
    ::google::protobuf::internal::ArenaStringPtr reducefunction_;
    ::google::protobuf::internal::ArenaStringPtr inputdatapath_;
    ::int32_t numreducers_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class FileChunk final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.FileChunk) */ {
 public:
  inline FileChunk() : FileChunk(nullptr) {}
  ~FileChunk() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileChunk(
      ::google::protobuf::internal::ConstantInitialized);

  inline FileChunk(const FileChunk& from) : FileChunk(nullptr, from) {}
  inline FileChunk(FileChunk&& from) noexcept
      : FileChunk(nullptr, std::move(from)) {}
  inline FileChunk& operator=(const FileChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileChunk& operator=(FileChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileChunk* internal_default_instance() {
    return reinterpret_cast<const FileChunk*>(
        &_FileChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(FileChunk& a, FileChunk& b) { a.Swap(&b); }
  inline void Swap(FileChunk* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileChunk* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FileChunk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileChunk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileChunk& from) { FileChunk::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FileChunk* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.FileChunk"; }

 protected:
  explicit FileChunk(::google::protobuf::Arena* arena);
  FileChunk(::google::protobuf::Arena* arena, const FileChunk& from);
  FileChunk(::google::protobuf::Arena* arena, FileChunk&& from) noexcept
      : FileChunk(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:gridmr.FileChunk)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};
// -------------------------------------------------------------------

class TaskResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:gridmr.TaskResult) */ {
 public:
  inline TaskResult() : TaskResult(nullptr) {}
  ~TaskResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskResult(const TaskResult& from) : TaskResult(nullptr, from) {}
  inline TaskResult(TaskResult&& from) noexcept
      : TaskResult(nullptr, std::move(from)) {}
  inline TaskResult& operator=(const TaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResult& operator=(TaskResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResult* internal_default_instance() {
    return reinterpret_cast<const TaskResult*>(
        &_TaskResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(TaskResult& a, TaskResult& b) { a.Swap(&b); }
  inline void Swap(TaskResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskResult& from) { TaskResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "gridmr.TaskResult"; }

 protected:
  explicit TaskResult(::google::protobuf::Arena* arena);
  TaskResult(::google::protobuf::Arena* arena, const TaskResult& from);
  TaskResult(::google::protobuf::Arena* arena, TaskResult&& from) noexcept
      : TaskResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWordCountResultsFieldNumber = 5,
    kTaskIdFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kResultPathFieldNumber = 4,
    kWorkerIdFieldNumber = 6,
    kSuccessFieldNumber = 3,
  };
  // map<string, int32> wordCountResults = 5;
  int wordcountresults_size() const;
  private:
  int _internal_wordcountresults_size() const;

  public:
  void clear_wordcountresults() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& wordcountresults() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_wordcountresults();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_wordcountresults() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_wordcountresults();

  public:
  // string taskId = 1;
  void clear_taskid() ;
  const std::string& taskid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskid(Arg_&& arg, Args_... args);
  std::string* mutable_taskid();
  PROTOBUF_NODISCARD std::string* release_taskid();
  void set_allocated_taskid(std::string* value);

  private:
  const std::string& _internal_taskid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskid(
      const std::string& value);
  std::string* _internal_mutable_taskid();

  public:
  // string jobId = 2;
  void clear_jobid() ;
  const std::string& jobid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_jobid(Arg_&& arg, Args_... args);
  std::string* mutable_jobid();
  PROTOBUF_NODISCARD std::string* release_jobid();
  void set_allocated_jobid(std::string* value);

  private:
  const std::string& _internal_jobid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jobid(
      const std::string& value);
  std::string* _internal_mutable_jobid();

  public:
  // string resultPath = 4;
  void clear_resultpath() ;
  const std::string& resultpath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resultpath(Arg_&& arg, Args_... args);
  std::string* mutable_resultpath();
  PROTOBUF_NODISCARD std::string* release_resultpath();
  void set_allocated_resultpath(std::string* value);

  private:
  const std::string& _internal_resultpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resultpath(
      const std::string& value);
  std::string* _internal_mutable_resultpath();

  public:
  // string workerId = 6;
  void clear_workerid() ;
  const std::string& workerid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workerid(Arg_&& arg, Args_... args);
  std::string* mutable_workerid();
  PROTOBUF_NODISCARD std::string* release_workerid();
  void set_allocated_workerid(std::string* value);

  private:
  const std::string& _internal_workerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workerid(
      const std::string& value);
  std::string* _internal_mutable_workerid();

  public:
  // bool success = 3;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:gridmr.TaskResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<TaskResult_WordCountResultsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        wordcountresults_;
    ::google::protobuf::internal::ArenaStringPtr taskid_;
    ::google::protobuf::internal::ArenaStringPtr jobid_;
    ::google::protobuf::internal::ArenaStringPtr resultpath_;
    ::google::protobuf::internal::ArenaStringPtr workerid_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gridmr_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// JobRequest

// string jobId = 1;
inline void JobRequest::clear_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.ClearToEmpty();
}
inline const std::string& JobRequest::jobid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.JobRequest.jobId)
  return _internal_jobid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JobRequest::set_jobid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.JobRequest.jobId)
}
inline std::string* JobRequest::mutable_jobid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:gridmr.JobRequest.jobId)
  return _s;
}
inline const std::string& JobRequest::_internal_jobid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Get();
}
inline void JobRequest::_internal_set_jobid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.Set(value, GetArena());
}
inline std::string* JobRequest::_internal_mutable_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Mutable( GetArena());
}
inline std::string* JobRequest::release_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.JobRequest.jobId)
  return _impl_.jobid_.Release();
}
inline void JobRequest::set_allocated_jobid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jobid_.IsDefault()) {
          _impl_.jobid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.JobRequest.jobId)
}

// string mapFunction = 2;
inline void JobRequest::clear_mapfunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapfunction_.ClearToEmpty();
}
inline const std::string& JobRequest::mapfunction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.JobRequest.mapFunction)
  return _internal_mapfunction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JobRequest::set_mapfunction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapfunction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.JobRequest.mapFunction)
}
inline std::string* JobRequest::mutable_mapfunction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mapfunction();
  // @@protoc_insertion_point(field_mutable:gridmr.JobRequest.mapFunction)
  return _s;
}
inline const std::string& JobRequest::_internal_mapfunction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapfunction_.Get();
}
inline void JobRequest::_internal_set_mapfunction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapfunction_.Set(value, GetArena());
}
inline std::string* JobRequest::_internal_mutable_mapfunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.mapfunction_.Mutable( GetArena());
}
inline std::string* JobRequest::release_mapfunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.JobRequest.mapFunction)
  return _impl_.mapfunction_.Release();
}
inline void JobRequest::set_allocated_mapfunction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapfunction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mapfunction_.IsDefault()) {
          _impl_.mapfunction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.JobRequest.mapFunction)
}

// string reduceFunction = 3;
inline void JobRequest::clear_reducefunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reducefunction_.ClearToEmpty();
}
inline const std::string& JobRequest::reducefunction() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.JobRequest.reduceFunction)
  return _internal_reducefunction();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JobRequest::set_reducefunction(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reducefunction_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.JobRequest.reduceFunction)
}
inline std::string* JobRequest::mutable_reducefunction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reducefunction();
  // @@protoc_insertion_point(field_mutable:gridmr.JobRequest.reduceFunction)
  return _s;
}
inline const std::string& JobRequest::_internal_reducefunction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reducefunction_.Get();
}
inline void JobRequest::_internal_set_reducefunction(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reducefunction_.Set(value, GetArena());
}
inline std::string* JobRequest::_internal_mutable_reducefunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.reducefunction_.Mutable( GetArena());
}
inline std::string* JobRequest::release_reducefunction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.JobRequest.reduceFunction)
  return _impl_.reducefunction_.Release();
}
inline void JobRequest::set_allocated_reducefunction(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reducefunction_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reducefunction_.IsDefault()) {
          _impl_.reducefunction_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.JobRequest.reduceFunction)
}

// bytes inputDataPath = 4;
inline void JobRequest::clear_inputdatapath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inputdatapath_.ClearToEmpty();
}
inline const std::string& JobRequest::inputdatapath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.JobRequest.inputDataPath)
  return _internal_inputdatapath();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JobRequest::set_inputdatapath(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inputdatapath_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.JobRequest.inputDataPath)
}
inline std::string* JobRequest::mutable_inputdatapath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_inputdatapath();
  // @@protoc_insertion_point(field_mutable:gridmr.JobRequest.inputDataPath)
  return _s;
}
inline const std::string& JobRequest::_internal_inputdatapath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inputdatapath_.Get();
}
inline void JobRequest::_internal_set_inputdatapath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inputdatapath_.Set(value, GetArena());
}
inline std::string* JobRequest::_internal_mutable_inputdatapath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.inputdatapath_.Mutable( GetArena());
}
inline std::string* JobRequest::release_inputdatapath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.JobRequest.inputDataPath)
  return _impl_.inputdatapath_.Release();
}
inline void JobRequest::set_allocated_inputdatapath(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inputdatapath_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.inputdatapath_.IsDefault()) {
          _impl_.inputdatapath_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.JobRequest.inputDataPath)
}

// int32 numReducers = 5;
inline void JobRequest::clear_numreducers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numreducers_ = 0;
}
inline ::int32_t JobRequest::numreducers() const {
  // @@protoc_insertion_point(field_get:gridmr.JobRequest.numReducers)
  return _internal_numreducers();
}
inline void JobRequest::set_numreducers(::int32_t value) {
  _internal_set_numreducers(value);
  // @@protoc_insertion_point(field_set:gridmr.JobRequest.numReducers)
}
inline ::int32_t JobRequest::_internal_numreducers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numreducers_;
}
inline void JobRequest::_internal_set_numreducers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numreducers_ = value;
}

// -------------------------------------------------------------------

// JobResponse

// bool success = 1;
inline void JobResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool JobResponse::success() const {
  // @@protoc_insertion_point(field_get:gridmr.JobResponse.success)
  return _internal_success();
}
inline void JobResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:gridmr.JobResponse.success)
}
inline bool JobResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void JobResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

// string message = 2;
inline void JobResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& JobResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.JobResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void JobResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.JobResponse.message)
}
inline std::string* JobResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:gridmr.JobResponse.message)
  return _s;
}
inline const std::string& JobResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void JobResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* JobResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* JobResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.JobResponse.message)
  return _impl_.message_.Release();
}
inline void JobResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.JobResponse.message)
}

// -------------------------------------------------------------------

// WorkerRegistrationRequest

// string workerId = 1;
inline void WorkerRegistrationRequest::clear_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.ClearToEmpty();
}
inline const std::string& WorkerRegistrationRequest::workerid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.WorkerRegistrationRequest.workerId)
  return _internal_workerid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkerRegistrationRequest::set_workerid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.WorkerRegistrationRequest.workerId)
}
inline std::string* WorkerRegistrationRequest::mutable_workerid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_workerid();
  // @@protoc_insertion_point(field_mutable:gridmr.WorkerRegistrationRequest.workerId)
  return _s;
}
inline const std::string& WorkerRegistrationRequest::_internal_workerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.workerid_.Get();
}
inline void WorkerRegistrationRequest::_internal_set_workerid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.Set(value, GetArena());
}
inline std::string* WorkerRegistrationRequest::_internal_mutable_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.workerid_.Mutable( GetArena());
}
inline std::string* WorkerRegistrationRequest::release_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.WorkerRegistrationRequest.workerId)
  return _impl_.workerid_.Release();
}
inline void WorkerRegistrationRequest::set_allocated_workerid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.workerid_.IsDefault()) {
          _impl_.workerid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.WorkerRegistrationRequest.workerId)
}

// string address = 2;
inline void WorkerRegistrationRequest::clear_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& WorkerRegistrationRequest::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.WorkerRegistrationRequest.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkerRegistrationRequest::set_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.WorkerRegistrationRequest.address)
}
inline std::string* WorkerRegistrationRequest::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:gridmr.WorkerRegistrationRequest.address)
  return _s;
}
inline const std::string& WorkerRegistrationRequest::_internal_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.address_.Get();
}
inline void WorkerRegistrationRequest::_internal_set_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* WorkerRegistrationRequest::_internal_mutable_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* WorkerRegistrationRequest::release_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.WorkerRegistrationRequest.address)
  return _impl_.address_.Release();
}
inline void WorkerRegistrationRequest::set_allocated_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.WorkerRegistrationRequest.address)
}

// string capacity = 3;
inline void WorkerRegistrationRequest::clear_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_.ClearToEmpty();
}
inline const std::string& WorkerRegistrationRequest::capacity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.WorkerRegistrationRequest.capacity)
  return _internal_capacity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkerRegistrationRequest::set_capacity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.WorkerRegistrationRequest.capacity)
}
inline std::string* WorkerRegistrationRequest::mutable_capacity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_capacity();
  // @@protoc_insertion_point(field_mutable:gridmr.WorkerRegistrationRequest.capacity)
  return _s;
}
inline const std::string& WorkerRegistrationRequest::_internal_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_.Get();
}
inline void WorkerRegistrationRequest::_internal_set_capacity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_.Set(value, GetArena());
}
inline std::string* WorkerRegistrationRequest::_internal_mutable_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.capacity_.Mutable( GetArena());
}
inline std::string* WorkerRegistrationRequest::release_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.WorkerRegistrationRequest.capacity)
  return _impl_.capacity_.Release();
}
inline void WorkerRegistrationRequest::set_allocated_capacity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.capacity_.IsDefault()) {
          _impl_.capacity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.WorkerRegistrationRequest.capacity)
}

// -------------------------------------------------------------------

// WorkerRegistrationResponse

// bool success = 1;
inline void WorkerRegistrationResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool WorkerRegistrationResponse::success() const {
  // @@protoc_insertion_point(field_get:gridmr.WorkerRegistrationResponse.success)
  return _internal_success();
}
inline void WorkerRegistrationResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:gridmr.WorkerRegistrationResponse.success)
}
inline bool WorkerRegistrationResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void WorkerRegistrationResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// TaskRequest

// string workerId = 1;
inline void TaskRequest::clear_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.ClearToEmpty();
}
inline const std::string& TaskRequest::workerid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskRequest.workerId)
  return _internal_workerid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskRequest::set_workerid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskRequest.workerId)
}
inline std::string* TaskRequest::mutable_workerid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_workerid();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskRequest.workerId)
  return _s;
}
inline const std::string& TaskRequest::_internal_workerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.workerid_.Get();
}
inline void TaskRequest::_internal_set_workerid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.Set(value, GetArena());
}
inline std::string* TaskRequest::_internal_mutable_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.workerid_.Mutable( GetArena());
}
inline std::string* TaskRequest::release_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskRequest.workerId)
  return _impl_.workerid_.Release();
}
inline void TaskRequest::set_allocated_workerid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.workerid_.IsDefault()) {
          _impl_.workerid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskRequest.workerId)
}

// -------------------------------------------------------------------

// TaskResponse

// .gridmr.TaskResponse.TaskType taskType = 1;
inline void TaskResponse::clear_tasktype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasktype_ = 0;
}
inline ::gridmr::TaskResponse_TaskType TaskResponse::tasktype() const {
  // @@protoc_insertion_point(field_get:gridmr.TaskResponse.taskType)
  return _internal_tasktype();
}
inline void TaskResponse::set_tasktype(::gridmr::TaskResponse_TaskType value) {
  _internal_set_tasktype(value);
  // @@protoc_insertion_point(field_set:gridmr.TaskResponse.taskType)
}
inline ::gridmr::TaskResponse_TaskType TaskResponse::_internal_tasktype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::gridmr::TaskResponse_TaskType>(_impl_.tasktype_);
}
inline void TaskResponse::_internal_set_tasktype(::gridmr::TaskResponse_TaskType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasktype_ = value;
}

// string taskId = 2;
inline void TaskResponse::clear_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.ClearToEmpty();
}
inline const std::string& TaskResponse::taskid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResponse.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResponse::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResponse.taskId)
}
inline std::string* TaskResponse::mutable_taskid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResponse.taskId)
  return _s;
}
inline const std::string& TaskResponse::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void TaskResponse::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.Set(value, GetArena());
}
inline std::string* TaskResponse::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Mutable( GetArena());
}
inline std::string* TaskResponse::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResponse.taskId)
  return _impl_.taskid_.Release();
}
inline void TaskResponse::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResponse.taskId)
}

// string dataSplitPath = 3;
inline void TaskResponse::clear_datasplitpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datasplitpath_.ClearToEmpty();
}
inline const std::string& TaskResponse::datasplitpath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResponse.dataSplitPath)
  return _internal_datasplitpath();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResponse::set_datasplitpath(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datasplitpath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResponse.dataSplitPath)
}
inline std::string* TaskResponse::mutable_datasplitpath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_datasplitpath();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResponse.dataSplitPath)
  return _s;
}
inline const std::string& TaskResponse::_internal_datasplitpath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.datasplitpath_.Get();
}
inline void TaskResponse::_internal_set_datasplitpath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datasplitpath_.Set(value, GetArena());
}
inline std::string* TaskResponse::_internal_mutable_datasplitpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.datasplitpath_.Mutable( GetArena());
}
inline std::string* TaskResponse::release_datasplitpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResponse.dataSplitPath)
  return _impl_.datasplitpath_.Release();
}
inline void TaskResponse::set_allocated_datasplitpath(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.datasplitpath_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.datasplitpath_.IsDefault()) {
          _impl_.datasplitpath_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResponse.dataSplitPath)
}

// repeated string intermediateFiles = 4;
inline int TaskResponse::_internal_intermediatefiles_size() const {
  return _internal_intermediatefiles().size();
}
inline int TaskResponse::intermediatefiles_size() const {
  return _internal_intermediatefiles_size();
}
inline void TaskResponse::clear_intermediatefiles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.intermediatefiles_.Clear();
}
inline std::string* TaskResponse::add_intermediatefiles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_intermediatefiles()->Add();
  // @@protoc_insertion_point(field_add_mutable:gridmr.TaskResponse.intermediateFiles)
  return _s;
}
inline const std::string& TaskResponse::intermediatefiles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResponse.intermediateFiles)
  return _internal_intermediatefiles().Get(index);
}
inline std::string* TaskResponse::mutable_intermediatefiles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResponse.intermediateFiles)
  return _internal_mutable_intermediatefiles()->Mutable(index);
}
inline void TaskResponse::set_intermediatefiles(int index, const std::string& value) {
  _internal_mutable_intermediatefiles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::set_intermediatefiles(int index, std::string&& value) {
  _internal_mutable_intermediatefiles()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::set_intermediatefiles(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_intermediatefiles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::set_intermediatefiles(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_intermediatefiles()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::set_intermediatefiles(int index, absl::string_view value) {
  _internal_mutable_intermediatefiles()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::add_intermediatefiles(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_intermediatefiles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::add_intermediatefiles(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_intermediatefiles()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::add_intermediatefiles(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_intermediatefiles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::add_intermediatefiles(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_intermediatefiles()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gridmr.TaskResponse.intermediateFiles)
}
inline void TaskResponse::add_intermediatefiles(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_intermediatefiles()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:gridmr.TaskResponse.intermediateFiles)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskResponse::intermediatefiles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:gridmr.TaskResponse.intermediateFiles)
  return _internal_intermediatefiles();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TaskResponse::mutable_intermediatefiles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:gridmr.TaskResponse.intermediateFiles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_intermediatefiles();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TaskResponse::_internal_intermediatefiles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.intermediatefiles_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TaskResponse::_internal_mutable_intermediatefiles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.intermediatefiles_;
}

// string jobId = 5;
inline void TaskResponse::clear_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.ClearToEmpty();
}
inline const std::string& TaskResponse::jobid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResponse.jobId)
  return _internal_jobid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResponse::set_jobid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResponse.jobId)
}
inline std::string* TaskResponse::mutable_jobid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResponse.jobId)
  return _s;
}
inline const std::string& TaskResponse::_internal_jobid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Get();
}
inline void TaskResponse::_internal_set_jobid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.Set(value, GetArena());
}
inline std::string* TaskResponse::_internal_mutable_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Mutable( GetArena());
}
inline std::string* TaskResponse::release_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResponse.jobId)
  return _impl_.jobid_.Release();
}
inline void TaskResponse::set_allocated_jobid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jobid_.IsDefault()) {
          _impl_.jobid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResponse.jobId)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TaskResult

// string taskId = 1;
inline void TaskResult::clear_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.ClearToEmpty();
}
inline const std::string& TaskResult::taskid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResult.taskId)
  return _internal_taskid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResult::set_taskid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResult.taskId)
}
inline std::string* TaskResult::mutable_taskid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_taskid();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResult.taskId)
  return _s;
}
inline const std::string& TaskResult::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Get();
}
inline void TaskResult::_internal_set_taskid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.Set(value, GetArena());
}
inline std::string* TaskResult::_internal_mutable_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.taskid_.Mutable( GetArena());
}
inline std::string* TaskResult::release_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResult.taskId)
  return _impl_.taskid_.Release();
}
inline void TaskResult::set_allocated_taskid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskid_.IsDefault()) {
          _impl_.taskid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResult.taskId)
}

// string jobId = 2;
inline void TaskResult::clear_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.ClearToEmpty();
}
inline const std::string& TaskResult::jobid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResult.jobId)
  return _internal_jobid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResult::set_jobid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResult.jobId)
}
inline std::string* TaskResult::mutable_jobid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_jobid();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResult.jobId)
  return _s;
}
inline const std::string& TaskResult::_internal_jobid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Get();
}
inline void TaskResult::_internal_set_jobid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.Set(value, GetArena());
}
inline std::string* TaskResult::_internal_mutable_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.jobid_.Mutable( GetArena());
}
inline std::string* TaskResult::release_jobid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResult.jobId)
  return _impl_.jobid_.Release();
}
inline void TaskResult::set_allocated_jobid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.jobid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.jobid_.IsDefault()) {
          _impl_.jobid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResult.jobId)
}

// bool success = 3;
inline void TaskResult::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool TaskResult::success() const {
  // @@protoc_insertion_point(field_get:gridmr.TaskResult.success)
  return _internal_success();
}
inline void TaskResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:gridmr.TaskResult.success)
}
inline bool TaskResult::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void TaskResult::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

// string resultPath = 4;
inline void TaskResult::clear_resultpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resultpath_.ClearToEmpty();
}
inline const std::string& TaskResult::resultpath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResult.resultPath)
  return _internal_resultpath();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResult::set_resultpath(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resultpath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResult.resultPath)
}
inline std::string* TaskResult::mutable_resultpath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_resultpath();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResult.resultPath)
  return _s;
}
inline const std::string& TaskResult::_internal_resultpath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resultpath_.Get();
}
inline void TaskResult::_internal_set_resultpath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resultpath_.Set(value, GetArena());
}
inline std::string* TaskResult::_internal_mutable_resultpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.resultpath_.Mutable( GetArena());
}
inline std::string* TaskResult::release_resultpath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResult.resultPath)
  return _impl_.resultpath_.Release();
}
inline void TaskResult::set_allocated_resultpath(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resultpath_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resultpath_.IsDefault()) {
          _impl_.resultpath_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResult.resultPath)
}

// map<string, int32> wordCountResults = 5;
inline int TaskResult::_internal_wordcountresults_size() const {
  return _internal_wordcountresults().size();
}
inline int TaskResult::wordcountresults_size() const {
  return _internal_wordcountresults_size();
}
inline void TaskResult::clear_wordcountresults() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wordcountresults_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& TaskResult::_internal_wordcountresults() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wordcountresults_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& TaskResult::wordcountresults() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:gridmr.TaskResult.wordCountResults)
  return _internal_wordcountresults();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* TaskResult::_internal_mutable_wordcountresults() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.wordcountresults_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* TaskResult::mutable_wordcountresults() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:gridmr.TaskResult.wordCountResults)
  return _internal_mutable_wordcountresults();
}

// string workerId = 6;
inline void TaskResult::clear_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.ClearToEmpty();
}
inline const std::string& TaskResult::workerid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.TaskResult.workerId)
  return _internal_workerid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskResult::set_workerid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.TaskResult.workerId)
}
inline std::string* TaskResult::mutable_workerid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_workerid();
  // @@protoc_insertion_point(field_mutable:gridmr.TaskResult.workerId)
  return _s;
}
inline const std::string& TaskResult::_internal_workerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.workerid_.Get();
}
inline void TaskResult::_internal_set_workerid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.Set(value, GetArena());
}
inline std::string* TaskResult::_internal_mutable_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.workerid_.Mutable( GetArena());
}
inline std::string* TaskResult::release_workerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.TaskResult.workerId)
  return _impl_.workerid_.Release();
}
inline void TaskResult::set_allocated_workerid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.workerid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.workerid_.IsDefault()) {
          _impl_.workerid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.TaskResult.workerId)
}

// -------------------------------------------------------------------

// TaskResultResponse

// bool success = 1;
inline void TaskResultResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool TaskResultResponse::success() const {
  // @@protoc_insertion_point(field_get:gridmr.TaskResultResponse.success)
  return _internal_success();
}
inline void TaskResultResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:gridmr.TaskResultResponse.success)
}
inline bool TaskResultResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void TaskResultResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// ReceiveFileRequest

// string filePath = 1;
inline void ReceiveFileRequest::clear_filepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& ReceiveFileRequest::filepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.ReceiveFileRequest.filePath)
  return _internal_filepath();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReceiveFileRequest::set_filepath(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.ReceiveFileRequest.filePath)
}
inline std::string* ReceiveFileRequest::mutable_filepath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:gridmr.ReceiveFileRequest.filePath)
  return _s;
}
inline const std::string& ReceiveFileRequest::_internal_filepath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filepath_.Get();
}
inline void ReceiveFileRequest::_internal_set_filepath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.Set(value, GetArena());
}
inline std::string* ReceiveFileRequest::_internal_mutable_filepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.filepath_.Mutable( GetArena());
}
inline std::string* ReceiveFileRequest::release_filepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.ReceiveFileRequest.filePath)
  return _impl_.filepath_.Release();
}
inline void ReceiveFileRequest::set_allocated_filepath(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filepath_.IsDefault()) {
          _impl_.filepath_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.ReceiveFileRequest.filePath)
}

// -------------------------------------------------------------------

// FileChunk

// bytes data = 1;
inline void FileChunk::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& FileChunk::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:gridmr.FileChunk.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FileChunk::set_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:gridmr.FileChunk.data)
}
inline std::string* FileChunk::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:gridmr.FileChunk.data)
  return _s;
}
inline const std::string& FileChunk::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.data_.Get();
}
inline void FileChunk::_internal_set_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* FileChunk::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* FileChunk::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:gridmr.FileChunk.data)
  return _impl_.data_.Release();
}
inline void FileChunk::set_allocated_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridmr.FileChunk.data)
}

// -------------------------------------------------------------------

// SendFileResponse

// bool success = 1;
inline void SendFileResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool SendFileResponse::success() const {
  // @@protoc_insertion_point(field_get:gridmr.SendFileResponse.success)
  return _internal_success();
}
inline void SendFileResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:gridmr.SendFileResponse.success)
}
inline bool SendFileResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void SendFileResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace gridmr


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::gridmr::TaskResponse_TaskType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::gridmr::TaskResponse_TaskType>() {
  return ::gridmr::TaskResponse_TaskType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_gridmr_2eproto_2epb_2eh
